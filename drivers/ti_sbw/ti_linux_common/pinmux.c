//*****************************************************************************
// pinmux.c
//
// configure the device pins for different peripheral signals
//
// Copyright (C) 2014 Texas Instruments Incorporated - http://www.ti.com/ 
// 
// 
//  Redistribution and use in source and binary forms, with or without 
//  modification, are permitted provided that the following conditions 
//  are met:
//
//    Redistributions of source code must retain the above copyright 
//    notice, this list of conditions and the following disclaimer.
//
//    Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the 
//    documentation and/or other materials provided with the   
//    distribution.
//
//    Neither the name of Texas Instruments Incorporated nor the names of
//    its contributors may be used to endorse or promote products derived
//    from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
//  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
//  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
//  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
//  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
//  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
//  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
//  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//*****************************************************************************

// This file was automatically generated by the CC31xx PinMux Utility
// Version: 1.0.2
//
//*****************************************************************************
#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <stdbool.h>
#include <fcntl.h>
#include <sys/mman.h>
#include "pinmux.h"
#include "gpio_if.h"
#include "dcdc_sbw.h"

//*****************************************************************************
//                      Defines
//*****************************************************************************
#define GPIO0_BASE 0x44E07000
#define GPIO1_BASE 0x4804C000
#define GPIO2_BASE 0x481AC000
#define GPIO3_BASE 0x481AE000

#define GPIO_SIZE  0x00000FFF

//*****************************************************************************
//                      GLOBAL VARIABLES
//*****************************************************************************
int mem_fd;
char *gpio_map;
volatile unsigned *gpio_port;

//*****************************************************************************
void
PinMuxConfig(void)
{
#if 0
	FILE *pFile = NULL;

	// SBW Pins
	sprintf(cmdString,"%d",32 + RESET_PIN);
	pFile = fopen("/sys/class/gpio/export", "w");
	fwrite(cmdString, 1, 2, pFile);
	fclose(pFile);

//	sprintf(cmdString,"/sys/class/gpio/gpio%d/direction",RESET_PIN);
//	pFile = fopen(cmdString, "w");
//	fwrite("out", 1, 3, pFile);
//	fclose(pFile);

	sprintf(cmdString,"%d",32 + TEST_PIN);
	pFile = fopen("/sys/class/gpio/export", "w");
	fwrite(cmdString, 1, 2, pFile);
	fclose(pFile);

//	sprintf(cmdString,"/sys/class/gpio/gpio%d/direction",TEST_PIN);
//	pFile = fopen(cmdString, "w");
//	fwrite("out", 1, 3, pFile);
//	fclose(pFile);

	// LEDs
	sprintf(cmdString,"%d",32 + LED1);
	pFile = fopen("/sys/class/gpio/export", "w");
	fwrite(cmdString, 1, 2, pFile);
	fclose(pFile);

//	sprintf(cmdString,"/sys/class/gpio/gpio%d/direction",LED1);
//	pFile = fopen(cmdString, "w");
//	fwrite("out", 1, 3, pFile);
//	fclose(pFile);

	sprintf(cmdString,"%d",32 + LED2);
	pFile = fopen("/sys/class/gpio/export", "w");
	fwrite(cmdString, 1, 2, pFile);
	fclose(pFile);

//	sprintf(cmdString,"/sys/class/gpio/gpio%d/direction",LED2);
//	pFile = fopen(cmdString, "w");
//	fwrite("out", 1, 3, pFile);
//	fclose(pFile);

	sprintf(cmdString,"%d",32 + LED3);
	pFile = fopen("/sys/class/gpio/export", "w");
	fwrite(cmdString, 1, 2, pFile);
	fclose(pFile);

//	sprintf(cmdString,"/sys/class/gpio/gpio%d/direction",LED3);
//	pFile = fopen(cmdString, "w");
//	fwrite("out", 1, 3, pFile);
//	fclose(pFile);

	sprintf(cmdString,"%d",32 + LED4);
	pFile = fopen("/sys/class/gpio/export", "w");
	fwrite(cmdString, 1, 2, pFile);
	fclose(pFile);

//	sprintf(cmdString,"/sys/class/gpio/gpio%d/direction",LED4);
//	pFile = fopen(cmdString, "w");
//	fwrite("out", 1, 3, pFile);
//	fclose(pFile);

//	printf("%s",cmdString);

	/* open /dev/mem */
    if ((mem_fd = open("/dev/mem", O_RDWR|O_SYNC) ) < 0) {
            printf("can't open /dev/mem \n");
            exit (-1);
    }

    /* mmap GPIO */
    gpio_map = (char *)mmap(
            0,
            GPIO_SIZE,
            PROT_READ|PROT_WRITE,
            MAP_SHARED,
            mem_fd,
            GPIO1_BASE
    );

    if (gpio_map == MAP_FAILED) {
            printf("mmap error %d\n", (int)gpio_map);
            exit (-1);
    }

    // Always use the volatile pointer!
    gpio_port = (volatile unsigned *)gpio_map;
#endif
}
